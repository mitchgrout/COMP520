// libc
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <stdint.h>
#include <math.h>
#include <stdarg.h>

// STL
#include <stack>
#include <vector>
#include <map>
using namespace std;

// Log to stream
static inline void log(FILE *stream, const char *fmt, ...)
{
    // Print timestamp
    {
        char buf[8+1];
        time_t t;
        time(&t);
        struct tm *info = localtime(&t);
        strftime(buf, 9, "%H:%M:%S", info);
        fprintf(stream, "[%s] ", buf);
    }
    // Print fmt
    {
        va_list args;
        va_start(args, fmt);
        vfprintf(stream, fmt, args);
        fputc('\n', stream);
        va_end(args);
    }
}

// Consts
#define BLOCK_SIZE 64
#define DIGEST_SIZE 32

// MAW internals
static inline uint8_t rotr(const uint8_t x, const uint8_t n) { return (x >> n) | (x << (8 - n)); }
static inline uint8_t maj(const uint8_t x, const uint8_t y, const uint8_t z) { return (x & y) ^ (x & z) ^ (y & z); }
static inline uint8_t sigma0(const uint8_t x) { return rotr(x, 2) ^ rotr(x, 3) ^ rotr(x, 5); }
static inline uint8_t sigma1(const uint8_t x) { return rotr(x, 1) ^ rotr(x, 4) ^ (x >> 3); }
static inline uint8_t add(const uint8_t x, const uint8_t y) { return x + y; }

// Derivatives
static inline uint8_t maj_diff(const uint8_t x,   const uint8_t y,   const uint8_t z,
                               const uint8_t d_x, const uint8_t d_y, const uint8_t d_z)
{
    return maj(x, y, z) ^ maj(x^d_x, y^d_y, z^d_z);
}

static inline uint8_t add_diff(const uint8_t x,   const uint8_t y, 
                               const uint8_t d_x, const uint8_t d_y)
{
    return add(x, y) ^ add(x ^ d_x, y ^ d_y);
}

static inline uint8_t keymix_diff(const uint8_t x, const uint8_t d_x, const size_t round)
{
    const uint8_t K[16] = 
    {
        0xb7, 0xe1, 0x51, 0x62, 0x8a, 0xed, 0x2a, 0x6a,
        0xbf, 0x71, 0x58, 0x80, 0x9c, 0xf4, 0xf3, 0xc7
    };
    return add(x, K[round]) ^ add(x ^ d_x, K[round]);
}

// Propagation state
struct prop_state
{
    size_t round;               // Which round we are currently propagating
    size_t step;                // Which step in particular
    uint8_t sched[16];          // Differences in message schedule
    union 
    {
        struct { uint8_t a, b, c, d; }; // Current registers
        uint32_t diff;          // Registers as a 32-bit int
    };
    uint8_t t1, t2, maj;        // Differences in temporary variables
    union
    {
        uint8_t trail[4*16];    // Trail of differences
        uint32_t trail32[16];   //
    };
};

// Util 
static inline int prop_state_equal(const struct prop_state left, const struct prop_state right)
{
    return left.round == right.round &&
           left.step  == right.step; 
}

// Linear
static inline uint8_t propagate_sigma0(const uint8_t d_m)
{
    return sigma0(0 ^ d_m) ^ sigma0(0);
}

// Linear
static inline uint8_t propagate_sigma1(const uint8_t d_m)
{
    return sigma1(0 ^ d_m) ^ sigma1(0);
}

// Util
static inline vector<uint8_t> filter(const map<uint8_t, size_t>& samples, const size_t sample_size, const float l2pthresh)
{
    vector<uint8_t> results;
    for (const auto& elem : samples)
    {
        float prob = log2f(elem.second) - log2f(sample_size);
        if (prob >= l2pthresh) results.push_back(elem.first);
    }
    return results;
}

// Nonlinear
static map<uint16_t, vector<uint8_t>> key_memo;
static inline uint16_t keymix_map_key(uint8_t d_x, uint8_t round) { return (d_x << 8) | (round & 0xf); }
vector<uint8_t> propagate_keymix(const uint8_t d_x, const size_t round, const float l2pthresh)
{
    // Memoization
    uint16_t key = keymix_map_key(d_x, round);
    if (key_memo.find(key) != key_memo.end()) return key_memo[key];
    log(stdout, "Key memo missing: %d/%zu\n", d_x, round);

    const size_t sample_size = 256;
    map<uint8_t, size_t> counts;

    // Sample
    for (int n = 0; n < sample_size; n++)
    {
        uint8_t x = n;
        counts[keymix_diff(x, d_x, round)]++;
    }
    vector<uint8_t> result = filter(counts, sample_size, l2pthresh);
    key_memo[key] = result;
    return result;
}

// Nonlinear
static map<uint16_t, vector<uint8_t>> add_memo;
static inline uint16_t add_map_key(uint8_t d_x, uint8_t d_y) { return (d_x << 8) | d_y; }
vector<uint8_t> propagate_add(const uint8_t d_x, const uint8_t d_y, const float l2pthresh)
{
    // Memoization
    uint16_t key = add_map_key(d_x, d_y);
    if (add_memo.find(key) != add_memo.end()) return add_memo[key];
    log(stdout, "Add memo missing: %d/%d\n", d_x, d_y);

    const size_t sample_size = 256*256;
    map<uint8_t, size_t> counts;

    // Sample
    for (int n = 0; n < sample_size; n++)
    {
        uint8_t x = (n >> 8) & 0xff,
                y = (n >> 0) & 0xff;
        counts[add_diff(x, y, d_x, d_y)]++;
    }
    vector<uint8_t> result = filter(counts, sample_size, l2pthresh);
    add_memo[key] = result;
    return result;
}

// Nonlinear
static map<uint32_t, vector<uint8_t>> maj_memo;
static inline uint32_t maj_map_key(uint8_t d_x, uint8_t d_y, uint8_t d_z) { return (d_x << 16) | (d_y << 8) | d_z; }
vector<uint8_t> propagate_maj(const uint8_t d_x, const uint8_t d_y, const uint8_t d_z, const float l2pthresh)
{
    // Memoization
    uint32_t key = maj_map_key(d_x, d_y, d_z);
    if (maj_memo.find(key) != maj_memo.end()) return maj_memo[key];
    log(stdout, "Maj memo missing: %d/%d/%d\n", d_x, d_y, d_z);

    const size_t sample_size = 256*256;
    map<uint8_t, size_t> counts;

    // Sample
    for (int n = 0; n < sample_size; n++)
    {
        uint8_t x = rand() & 0xff,
                y = rand() & 0xff,
                z = rand() & 0xff;
        counts[maj_diff(x, y, z, d_x, d_y, d_z)]++;
    }
    vector<uint8_t> result = filter(counts, sample_size, l2pthresh);
    maj_memo[key] = result;
    return result;
}

// Take a differential, and propagate through to round n.
pair<size_t, size_t> propagate(const uint8_t *msg_diff, const size_t n, const float pthresh)
{
    // Must have a message diff
    if (!msg_diff)
    {
        log(stdout, "Error: Invalid message difference supplied. Aborting");
        exit(1);
    }
    // 16 rounds max
    if (n > 16)
    {
        log(stdout, "Error: Cannot propagate over more than 16 rounds maximum. Aborting");
        exit(1);
    }
    // Probability should be as a logarithm, hence nonpositive
    if (pthresh > 0)
    {
        log(stdout, "Error: Cannot have a positive log2 probability. Aborting");
        exit(1);
    }

    // Statistics
    size_t total_trails = 0,
           zero_trails  = 0;
    time_t start_time = time(NULL);

    // Backtracking value
    stack<pair<struct prop_state, vector<uint8_t>>> stack;

    // Build the default state objects
    struct prop_state sstate;
    memset(&sstate, 0, sizeof(sstate));
    vector<uint8_t> svec;

    // Set up the message schedule differentials; first 8 are concrete, but the
    // last 8 will be variable (non-linear transforms of the message)
    for (int i = 0; i < 8; i++) sstate.sched[i] = msg_diff[i];

    // Push our start state onto the stack to to kickstart the propagation process
    stack.push(make_pair(sstate, svec));
   
    bool b = false;
    // Stack contains points where we can restart a propagation
    while (!stack.empty())
    {
        // Grab the propagation state on top
        struct prop_state state = stack.top().first;
        // !!! Somehow need for force sstate off the stack
        if (b && prop_state_equal(sstate, state)) break;
        b = true;
        // !!!

        // Run this propagation through to completion
        while (state.round < n)
        {
            // We can actually use a quick heuristic here: 
            // registers a, c, are not changed, only moved to new registers. So
            // to get an output difference of 0 in the final round, a=c=0.
            if (state.round == n - 1 && (state.a != 0 || state.c != 0)) goto BAILOUT;
            switch (state.step)
            {
                #define PROP_START(...)                         \
                if (!prop_state_equal(state, stack.top().first))\
                {                                               \
                    vector<uint8_t> vec = __VA_ARGS__;          \
                    if (vec.size() == 0) goto BAILOUT;          \
                    stack.push(make_pair(state, vec));          \
                }

                #define PROP_INTROS                         \
                vector<uint8_t>& vec = stack.top().second;  \
                uint8_t diff         = vec.back();          \
                vec.pop_back();

                #define PROP_END if (vec.size() == 0) stack.pop();

                #define t (state.round)

                case 0:
                    {
                        // t1 = sigma1(b)
                        state.t1    = propagate_sigma1(state.b);
                        state.step += 1;
                        break;
                    }

                case 1:
                    {
                        // t1 = t1 + d
                        PROP_START(propagate_add(state.t1, state.d, pthresh));
                        PROP_INTROS;
                        state.t1    = diff;
                        state.step += 1;
                        PROP_END;
                        break;
                    }

                case 2:
                    {
                        // t1 = t1 + K[t]
                        PROP_START(propagate_keymix(state.t1, state.round, pthresh));
                        PROP_INTROS;
                        state.t1    = diff;
                        state.step += t < 8? 3 : 1;
                        PROP_END;
                        break;
                    }

                case 3:
                    {
                        // t >= 8: W[t] = sigma0(W[t-3]) + W[t-4]
                        PROP_START(propagate_add(propagate_sigma0(state.sched[t-3]), state.sched[t-4], pthresh));
                        PROP_INTROS;
                        state.sched[t] = diff;
                        state.step    += 1;
                        PROP_END;
                        break;
                    }

                case 4:
                    {
                        // t >= 8: W[t] = sigma1(W[t-8]) + W[t]
                        PROP_START(propagate_add(propagate_sigma1(state.sched[t-8]), state.sched[t], pthresh));
                        PROP_INTROS;
                        state.sched[t] = diff;
                        state.step    += 1;
                        PROP_END;
                        break;
                    }

                case 5:
                    {
                        // t1 = t1 + W[t]
                        PROP_START(propagate_add(state.t1, state.sched[t], pthresh));
                        PROP_INTROS;
                        state.t1    = diff;
                        state.step += 1;
                        PROP_END;
                        break;
                    }
                case 6:
                    {
                        // t2 = sigma0(a)
                        state.t2    = propagate_sigma0(state.a);
                        state.step += 1;
                        break;
                    }
                case 7:
                    {
                        // maj = maj(a, b, c)
                        PROP_START(propagate_maj(state.a, state.b, state.c, pthresh));
                        PROP_INTROS;
                        state.maj   = diff;
                        state.step += 1;
                        PROP_END;
                        break;
                    }

                case 8:
                    {
                        // t2 = t2 + maj
                        PROP_START(propagate_add(state.t2, state.maj, pthresh));
                        PROP_INTROS;
                        state.t2    = diff;
                        state.step += 1;
                        PROP_END;
                        break;
                    }

                case 9:
                    {
                        // d = c; c = b + t1
                        PROP_START(propagate_add(state.b, state.t1, pthresh));
                        PROP_INTROS;
                        state.d     = state.c;
                        state.c     = diff;
                        state.step += 1;
                        PROP_END;
                        break;
                    }

                case 10:
                    {
                        // b = a; a = t1 + t2
                        PROP_START(propagate_add(state.t1, state.t2, pthresh));
                        PROP_INTROS;
                        state.b          = state.a;
                        state.a          = diff;
                        state.trail32[t] = state.diff;
                        state.step       = 0;
                        state.round     += 1;
                        PROP_END;
                        break;
                    }

                default: // Impossible
                    break;

                #undef PROP_START
                #undef PROP_INTROS
                #undef PROP_END
                #undef t
            }
        }
        // Finished our search
        if (state.round == n)
        {
            total_trails++;
            zero_trails += !state.diff;
        }
        if (0)
        {
BAILOUT:
            total_trails++;
        }
    }
    return make_pair(zero_trails, total_trails);
}

// Determine if an input differential is viable
static inline bool is_viable(uint8_t *W, const size_t rounds, const float l2pthresh,
                             size_t t, size_t ctr)
{
    if (t >= 16) return ctr >= 0;   // 2/8
    uint8_t w0 = sigma0(W[t-3]),
            w1 = sigma1(W[t-8]);
    for (uint8_t t1: propagate_add(w0, w1, l2pthresh))
    for (uint8_t t2: propagate_add(W[t-4], t1, l2pthresh))
    {
        W[t] = t2;
        if (is_viable(W, rounds, l2pthresh, t+1, ctr + !t2)) return true;
    }
    return false;
}

// Successor of an array of bytes
static inline bool succ(uint8_t *ptr, size_t len)
{
    // Increment elements right-to-left, stopping if there is no carry
    while (len) if (++ptr[--len]) return true;
    return false;
}

// Create an input differential randomly
uint8_t *make_input_diff(size_t rounds, float l2pthresh)
{
    // The entire message schedule
    static uint8_t sched[16];

    // Randomly assign differences for last three words
    for (int idx = 0; idx < 8; idx++)
    {
        sched[idx] = (idx < 4)? 0 : rand();
    }
    // If not viable, mutate slightly
    while (!is_viable(sched, rounds, l2pthresh, 8, 0)) succ(sched, 8) ;
    return sched;
}

// Entry point
int main(int argc, char **argv)
{
    unsigned int seed = time(NULL);
    srand(seed);
    const float pthresh = -4.000000f;
    const size_t rounds = 16;
    uint8_t buffer[512];

    log(stdout, "Initializing...");
    if (FILE *key_file = fopen("/Scratch/key-file-4.000000.bin", "r"))
    {
        while (1)
        {
            // Read in the 3 arguments, giving up if we can't read every one
            if (fread(buffer, sizeof(uint8_t), 3, key_file) != 3) break;
            uint8_t d_x = buffer[0], round = buffer[1], len = buffer[2];
            // Then read the contents, and copy them in to the map
            if (fread(buffer, sizeof(uint8_t), len, key_file) != len) break; 
            vector<uint8_t> result(buffer, buffer + len);
            key_memo[keymix_map_key(d_x, round)] = result;
        }
        fclose(key_file);
        log(stdout, "Loaded key memos!");
    }
    else
    {
        log(stdout, "No key memos found!");
    }

    if (FILE *add_file = fopen("/Scratch/add-file-4.000000.bin", "r"))
    {
        while (1)
        {
            // Read in the 3 arguments, giving up if we can't read every one
            if (fread(buffer, sizeof(uint8_t), 3, add_file) != 3) break;
            uint8_t d_x = buffer[0], d_y = buffer[1], len = buffer[2];
            // Then read the contents, and copy them in to the map
            if (fread(buffer, sizeof(uint8_t), len, add_file) != len) break; 
            vector<uint8_t> result(buffer, buffer + len);
            add_memo[add_map_key(d_x, d_y)] = result;
        }
        fclose(add_file);
        log(stdout, "Loaded add memos!");
    }
    else
    {
        log(stdout, "No add memos found!");
    }

    if (FILE *maj_file = fopen("/Scratch/maj-file-4.000000.bin", "r"))
    {
        while (1)
        {
            // Read in the 4 arguments, giving up if we can't read every one
            if (fread(buffer, sizeof(uint8_t), 4, maj_file) != 4) break;
            uint8_t d_x = buffer[0], d_y = buffer[1], d_z = buffer[2], len = buffer[3];
            // Then read the contents, and copy them in to the map
            if (fread(buffer, sizeof(uint8_t), len, maj_file) != len) break; 
            vector<uint8_t> result(buffer, buffer + len);
            maj_memo[maj_map_key(d_x, d_y, d_z)] = result;
        }
        fclose(maj_file);
        log(stdout, "Loaded maj memos!");
    }
    else
    {
        log(stdout, "No maj memos found!");
    }
    log(stdout, "Initialization finished.");

    do
    {
        // Reseed so we can deterministically perform a propagation
        seed = rand();
        srand(seed);

        // Build an input differential, print it out
        uint8_t *diff = make_input_diff(rounds, pthresh);
        log(stdout, "Fingerprint:");
        for (int i = 0; i < 8; i++)
        {
            #define C2B(c) ((c)? 'x' : '-')
            log(stdout, "%c%c%c%c%c%c%c%c", 
                    C2B(diff[i] & 0x80),
                    C2B(diff[i] & 0x40),
                    C2B(diff[i] & 0x20),
                    C2B(diff[i] & 0x10),
                    C2B(diff[i] & 0x08),
                    C2B(diff[i] & 0x04),
                    C2B(diff[i] & 0x02),
                    C2B(diff[i] & 0x01));
            #undef C2B
        }
        log(stdout, "Seed: %u", seed);
        log(stdout, "Rounds: %zu/16", rounds);
        log(stdout, "Threshold probability: 2^%f", pthresh);
        pair<size_t, size_t> result = propagate(diff, rounds, pthresh);
        log(stdout, "Trails: %zu/%zu\n", result.first, result.second);
    }
    while (1);
    return 0;
}
