23/03:

Too busy with 518 to do work on 520
Need to change code to work with arbitrary differences; how to easily store
this?
Need 16 possible values: exactly 4 bytes. Use nibbles?
GCC has built-in bitmaps, so we can just have:
uint32_t nibble: 4;
+ unions to use a uint32_t as an array of 8 4-bit integers
Also extensible for things like SHA256; just add more 32-bit integers and
nibbles
In comparison to storing exact XOR differences: 4x as expensive memory-wise.

How to propagate a generalized difference?
Does linearity of sigma* still hold in these conditions?
My guess: yes
Assumption: XOR difference is just a special case of a useful property: if k is
our bit diff, we can write k as a union of 0, 1, u, n
Assumption: diff_f(k) = diff_f(...) ^ diff_f(...) ^ ... -- do every component,
    and xor together - XOR because thats how we view differences

    IDEA: We use the greediest algorithm possible to find the ***exact***
    difference
    in the bits that can explain the difference in outputs. All other diffs.
    will be
    some subset of that?

    No, because in all cases the most *specific* one will always be true.
    Start from the opposite end: we find the most *specific* ones that hold
    (which
     are 0un1), and use those as building-blocks to construct the
    others.
    Can build more specific ones by OR'ing results

    Alternatively we avoid using generalized differences in favour of pure
    XOR
    differences for the time being?

    Current approach seems to work: inspect each bit of the result, use that
    to
    decide if it is 01un, gives expected results for when input is xor diff

    DECISION: Trying to get generalized differences working at the moment is
    slowing
    progress. Better to stick with XOR difference which is space-efficient
    and easy
    to work with.


    Seems to be working now. Added explicit memoization to propagation
    functions.

    Important result:
    Using boolean property x & (y ^ z) == (x & z) ^ (x & z), we can reduce
    maj_diffs
    to:
    (d_y == d_z? d_y : x) ^
    (d_x == d_z? d_x : y) ^
    (d_x == d_y? d_x : z) -- a nice selector property
