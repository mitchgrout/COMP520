14/03/18:
Began work on implementing MAW32 trail searching
Decided to use C++ for STL + containers, rather than pure C
Wrote simple input differential generator; guesses first 4 words to be equal
(-), then randomly assigns last 4 words, excluding the contradiction #. Guess
based off of SHA-2 collision improvement paper (takes first 8 words to be
        unconstrained); may need to be reduced to 2 words later
Fully random choice for remaining bits may not be a good idea

Propagation: 
We know that sigma0 is linear -> preserves differentials 100% (by bruteforce);
propagation requires only one computation
Same is true of sigma1
Maj/Add do not follow this rule; we have to use random sampling to deal with
these

Propagation of a single round can be seen as follows:
- Get the current differentials for registers a, b, c, d
- Find the differential of sigma1(b)
    - Differential of K[t] can be ignored
    - Find the differential of W[t]
    - Add the three given differentials to d, to get the differential for t1
    - Find the differential of sigma0(a)
    - Find the differential of maj(a,b,c)
    - Find the differential of b+t1
    - Find the differential of t1+t2
    - Rotate
    This completes a round propagation

    At the end we want the differentials of a, b, c, d, to all be zero
    => the characteristic ends at a differential of zero, hence a [local]
    collision

    Start with t<=8 rounds

    How to compute differentials? Full space search for maj/add; works since we
    have <=2^24 elements in domain, easy to bruteforce. Generalization is to do
    random sampling

    How to efficiently propagate through n rounds?
    propagate(char *d, size_t n) <- propagate diff to round n, collect good
    trails

    Need to keep state for certain operations; for add/maj, we can get more than
    one output differential with <1 probabilty, should check all good paths, so
    we either need to recurse [*not* good] or keep a  stack [preferable]. Stack
    should keep info about the current round, and position through propagation
    [i.e. what was the last propgation that happened], + current differentials
    for registers etc

    Realised that fully random dense sections not a very good idea at the moment
    – in the beginning building differential by checking if != ‘-’ and if so
    setting that bit 1, otherwise 0
