08/05/18:

Hiatus due to stress/518/other classes.
In SHA256 + most other algos we can restructure to be in terms of A, C only
where b = A[i-1], d = C[i-1]
i.e. only registers A and C are important
MAW32 has the following restructuring:

a := A[i]
b := A[i-1]
c := C[i]
d := C[i-1]

update(t):
C[i] = A[i-2] + (C[i-2] + sigma1(A[i-2]) + K[i] + W[i])
A[i] = C[i] + (-A[i-2]) + (sigma0(A[i-1]) + maj(A[i-1], A[i-2], C[i-1]))

Using this for propagation does not work well due to locality of data. Slows
down by factors of 1000s (i.e. 5s to propagate with registers, half an hour to
propagate with arrays)
Better to have as a conceptual thing

Why is propagation slow? Too many branches to take. With a l2pthresh=p, there
are max. 2^(-p) branches to take at every node, and ~8 levels per round. of
these 8 rounds will contain these, so 64 levels each with max. 2^(-p) branches.
How to fix this? Either substantially reduce p, or we need to cull branches
somehow.

Decided before that sufficient conditions should be computed *after* to avoid
unnecessary slowdown, maybe computing them *during* propagation will actually
speed it up?
Consider: impose conditions on A[i], C[i], A[i-1], C[i-1], during every
propagation of a component. In next propagations we can slowly make conditions
more and more strict, and if we hit a contradiction we can BAILOUT
This should make the tree more manageable + smaller => faster propagations

Have also implemented the genetic algorithm; pretty sure it *works*, but results
are no good (ran for 24 hours, couldnt get past generation zero)

How to compute "sufficient conditions"? Since MAW32 is small, start off by
tracking what values A[i],...., can actually *be* by keeping a vector<uint8_t>
Take intersections to make conditions more stringent, if we hit an empty vector
we have a contradiction. Very bloated but the most bruteforce solution i can
think of so far. Only needs to be applied to keymix, add, and maj (the three
nonlinear funcs)
